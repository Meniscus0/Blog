## Day1

### 704. 二分查找

   这道题分为两种情况，首先求出数组长度nums.size()，因为下标从0开始，所以如果不减1，nums.size()所对应的值超过了有值元素的边界，所以是从数组外面开始找，右边界和（左边界及左边界本身）夹住了查找范围，右边不能闭，否则一开始取不到最右侧在数组外的那个值，所以是左闭右开。因为是从右边界左边那个值开始查找，如果左右边界重合，左边界从2边界重合点向右查找，右边界从边界重合点左边的哪个元素开始向左查找，所查范围没有任何相交，是空集，所以<不能加等号。

​    如果nums.size()减一就是用（左边界及左边界本身）和（右边界及右边界本身）两者夹住了查找范围，故为左左闭右闭。需用小于等于号。

**int middle=left+((right-left)/2);// 防止溢出 等同于(left + right)/2  正常left+right可能数值过大，超过int所能表示的范围，先减法再加法可以减少概率**



### 27. 移除元素

2个指针都向右移动，每次右指针时向右移1，如果没有碰到val，就把快指针赋值给慢指针，（碰到val之前左右指针指向同一个元素，自身赋值给自身，）并且给慢指针也加1，碰到val后慢指针停一步，此次循环不进行任何操作，下次快指针右移，赋值给慢指针，慢指针再向右移快赋值给慢。(开始时其实是慢指针先走一步，因为二者都在下标0处，第一遍循环就触及到了if，进行了++。之后都是慢指针先走，慢指针不走了，快指针走一步此时才追平。最终返回慢指针下标。

看完这2道题的解析和视频后我又在vs上自己默写了一遍， 默写之后与答案对了一遍，提交到力扣上，希望可以扎实地掌握。

**纸上得来终觉浅，绝知此事要躬行。**

## Day2



### **977.有序数组的平方** 

**题目建议**： 本题关键在于理解双指针思想 

暴力解法:先平方 ，后排序。

**双指针法**

左负数，中间接近零，右正数，平方后两边大中间小

左右2个指针从头开始，互相比大小，谁更大就把值赋给新的数组，再向中间移动一格，注意从数组的最大下标开始赋值以满足非递减。

注意i<=j否则最后一个元素无法赋值到新数组中

### **209.长度最小的子数组**

**滑动窗口**，也是双指针的一种

值大于s，比较长度后左端就要向右移动缩小窗口

将开始的返回值设置为INT32_MAX,是int类型中最大的值

for里面套while，每次右端向右移动单位一，如果满足>=s，左端持续向右移动直到sum<s,之后进行下一次for循环，右端向右移动一。

如果一直移动，直到整个数组的和都无法大于s，则返回0，说明没有这样的子序列

其中2次使用" ?	: 	"结构简化代码

时间复杂度：尽管for套了while，但是每个元素进出共2次，2*n  所以是O

(n)。



###  **59.螺旋矩阵II**

**题目建议**：  本题关键还是在转圈的逻辑，在二分搜索中提到的区间定义，在这里又用上了。 

**坚持循环不变量原则**

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220922102236.png" alt="img" style="zoom:25%;" />

如图，区间左开右闭

```C++
 vector<vector<int>> res(n, vector<int>(n, 0)); 
// 使用vector定义一个二维数组

 j < n - offset;
// offset 控制每一圈里每一条边遍历的长度
            offset += 1;
```

注意n为奇数时最中间元素需要单独处理，赋值count

别忘了开始int middle的用意

### 数组总结：

## Day3

### 定义链表节点方式(重点)

```C++
struct ListNode{
	int val;
	ListNode *next;
	ListNode(int x):val(x),next(NULL){}
}
//不定义构造函数
//初始化时，自己定义可赋值，默认定义不能赋值
ListNode* head=new ListNode(5);
ListNode* head=new ListNode();
head->val=5;
```

### 203.移除链表元素

**直接删除，头结点特殊处理**

头结点非空，头结点的值为val，用tmp中介

非头结点：cur初始时为head，该节点及下一个节点非空while循环，

如果下一个节点值为val，把下下个节点赋给下个节点，否则cur向右移动搜索

最终返回头

**虚拟头结点**（注意别return了虚拟的节点）

设置虚拟，指向head，cur从虚拟开始，之后仿照上面非头节点处理方式一视同仁。

最后把虚拟的下一个结点赋给头结点，事了拂衣，删除虚拟，返回头。



###  **707.设计链表**

利用指针cur来遍历链表，不能使用head否则最后没法return。

注意插入结点的顺序，先利用该节点->next连接新节点和下个结点，再连接该节点和新节点，否则就找不到下个结点了。 

**第n个结点一定是cur->next，才能用cur去操纵**

定义链表：模版

初始化：（0)  0

**nullptr**: 

> 我们更习惯将指针初始化为 NULL。值得一提的是，NULL 并不是 C++ 的关键字，它是 C++ 为我们事先定义好的一个宏，并且它的值往往就是字面量 0（#define NULL 0）。
>
> C++11 标准并没有对 NULL 的宏定义做任何修改。为了修正 C++ 存在的这一 BUG，C++ 标准委员会最终决定另其炉灶，在 C++11 标准中引入一个新关键字，即 nullptr。
>
> **nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。**
>
> ~http://c.biancheng.net/~



get：看Index范围，cur从虚拟结点下一 个开始，while的次数为Index次，之后cur刚好移动到下标为Index的地方。返回cur的值即可。

addatHead：新结点值设为val，先连接右边，再链接左边，size++；

addAtTail： cur从虚拟开始，cur下一个不为空时一直向右移动，while循环停止后把新节点赋给cur的下一个，此时cur的下一个为空，直接赋值就好；size++

addAtIndex:  依题意判断特殊范围，新节点和指针的设置和加尾函数一样处理，while循环和get函数一致，然后先右边再左边搭建newNode。size++

deleteIndex: 判断范围，cur为虚拟，向右遍历直到Index耗尽，借用tmp三步法删除结点。size--

打印： cur为虚拟，遍历直到下个为空，输出每一个指针next的值，最后endl，

```c++
private:
    int _size;
    LinkedNode* _dummyHead;
```

> private: 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象也不能访问.
>
> 类的private成员不能直接被类的实体访问，也不能被子类的实体访问，但是可以被类的成员函数访问；





###  **206.反转链表**

#### 双指针法

pre,cur,tmp不断向右移动，cur把next保存到tmp后就指向pre，之后3个指针通过赋值向右平移，直到cur移动到了NULL，此时pre是新的头，return即可。

^细品这4个语句，强化语感^

```c++
			tmp=cur->next;
            cur->next=pre;
            pre=cur;
            cur=tmp;
```

#### 递归法

1. 双指针的思路

   ```c++
    return reverse(NULL, head);
    //刚开始pre是NULL ，cur在head				
   ```

    

2. 从后往前翻转

   ![image-20230105185833802](https://cdn.jsdelivr.net/gh/Meniscus0/FigureBed@main/img/image-20230105185833802.png)

   

